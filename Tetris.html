<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris — Ryan Animashan · Nimbus LLC</title>
  <style>
    html,body{height:100%;margin:0;background:#0b7a3b;display:flex;align-items:center;justify-content:center;font-family:sans-serif;color:#fff}
    #startScreen,#gameWrapper{max-width:1100px;width:100%}
    #startScreen{display:flex;flex-direction:column;align-items:center;gap:1rem;background:#064e3b;padding:2rem;border-radius:1rem;box-shadow:0 6px 20px rgba(0,0,0,0.4)}
    h1{color:#ff8c1a;margin:0;font-size:clamp(28px,6vw,48px)}
    p{margin:0;font-size:1rem;opacity:0.9}
    button{background:#ff8c1a;color:#000;border:none;padding:14px 22px;border-radius:12px;font-weight:700;cursor:pointer}
    #gameWrapper{display:none;position:relative}
    #hud{position:absolute;top:8px;left:8px;background:#ffffffdd;color:#000;padding:6px 10px;border-radius:8px;font-weight:700}
    #muteBtn{position:absolute;top:8px;right:8px;background:#fff;color:#000;border-radius:8px;border:none;padding:6px 10px;font-weight:700;cursor:pointer}
    #overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.55)}
    #overlay .card{background:#fff;color:#111;padding:18px 22px;border-radius:12px;min-width:280px;text-align:center}
    #overlay .card h2{margin:0 0 10px}
    #overlay .card p{margin:6px 0}
    #overlay .actions{margin-top:12px;display:flex;gap:8px;justify-content:center}
    #overlay .actions button{background:#0ea5e9;color:#fff;border:none;border-radius:10px;padding:10px 14px;cursor:pointer;font-weight:800}
  </style>
  <script src="phaser.min.js"></script>
</head>
<body>
<div id="startScreen">
  <h1>Nimbus Tetris</h1>
  <p>by Ryan Animashan — Nimbus LLC</p>
  <button id="startBtn">Start Game</button>
  <p id="countdownText">Starting automatically in 3 seconds…</p>
</div>
<div id="gameWrapper">
  <div id="hud">Score: <span id="scoreText">0</span> | Lines: <span id="linesText">0</span> | Level: <span id="levelText">1</span></div>
  <button id="muteBtn">Mute</button>
  <div id="phaser-parent"></div>
  <div id="overlay"><div class="card">
    <h2>Game Over</h2>
    <p>Score: <span id="finalScore">0</span></p>
    <p>Lines: <span id="finalLines">0</span> — Level: <span id="finalLevel">1</span></p>
    <div class="actions">
      <button id="restartBtn">Restart</button>
    </div>
  </div></div>
</div>
<script>
(function(){
  // ===== Audio engine (no private fields) =====
  const Audio = {
    ctx:null, master:null, isMuted:false, volume:0.25,
    start(){ if(!this.ctx){ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); this.master=this.ctx.createGain(); this.master.gain.value=this.volume; this.master.connect(this.ctx.destination); this.build(); } if(this.ctx.state==='suspended') this.ctx.resume(); },
    muteToggle(){ this.isMuted=!this.isMuted; if(this.master) this.master.gain.value=this.isMuted?0:this.volume; },
    build(){ const bpm=120,beat=60/bpm,root=440; setInterval(()=>{ if(!this.ctx) return; const t=this.ctx.currentTime+0.05; for(let i=0;i<4;i++) this.tone(root/2,'square',t+i*beat,0.12); }, beat*4*1000); },
    tone(freq,type,t,len){ if(!this.ctx||!this.master) return; const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type=type; o.frequency.setValueAtTime(freq,t); o.connect(g); g.connect(this.master); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(.8,t+.01); g.gain.exponentialRampToValueAtTime(.001,t+len); o.start(t); o.stop(t+len+.05); }
  };

  // ===== DOM refs =====
  const startBtn=document.getElementById('startBtn');
  const startScreen=document.getElementById('startScreen');
  const countdownText=document.getElementById('countdownText');
  const gameWrapper=document.getElementById('gameWrapper');
  const muteBtn=document.getElementById('muteBtn');
  const scoreText=document.getElementById('scoreText');
  const linesText=document.getElementById('linesText');
  const levelText=document.getElementById('levelText');
  const overlay=document.getElementById('overlay');
  const finalScore=document.getElementById('finalScore');
  const finalLines=document.getElementById('finalLines');
  const finalLevel=document.getElementById('finalLevel');
  const restartBtn=document.getElementById('restartBtn');

  let countdown=3, countdownTimer=null, started=false;
  function startGame(){ if(started) return; started=true; clearInterval(countdownTimer); startScreen.style.display='none'; gameWrapper.style.display='block'; try{Audio.start();}catch(e){console.warn('Audio failed:',e);} bootPhaser(); }
  startBtn.addEventListener('click',startGame);
  window.addEventListener('keydown',(e)=>{ if(e.code==='Space'||e.code==='Enter') startGame(); });
  muteBtn.addEventListener('click',()=>Audio.muteToggle());

  function updateCountdown(){ countdownText.textContent=`Starting automatically in ${countdown} second${countdown===1?'':'s'}…`; if(countdown<=0){startGame();return;} countdown--; }
  countdownTimer=setInterval(updateCountdown,1000); updateCountdown();

  // ===== Phaser Tetris with Guideline-like scoring, level, ghost, hold, next, game over =====
  function bootPhaser(){
    const CELL=28, COLS=10, ROWS=20, PANEL=6*CELL; // side panel width
    const W = COLS*CELL + PANEL, H = ROWS*CELL;
    const COLORS={ I:0xff8c1a, J:0xffa733, L:0xffbb33, O:0xffd633, S:0xffc04d, T:0xffe066, Z:0xff9933, ghost:0x000000 };

    const config={ type:Phaser.AUTO, parent:'phaser-parent', width:W, height:H, backgroundColor:0x0b7a3b, scene:{ create, update } };
    const game=new Phaser.Game(config);

    // State
    let grid, active, ghost, queue=[], holdType=null, holdLocked=false, g;
    let dropTimer=0, dropInterval=500, score=0, lines=0, level=1;

    const SHAPES={ I:[[1,1,1,1]], J:[[1,0,0],[1,1,1]], L:[[0,0,1],[1,1,1]], O:[[1,1],[1,1]], S:[[0,1,1],[1,1,0]], T:[[0,1,0],[1,1,1]], Z:[[1,1,0],[0,1,1]] };
    const TYPES=Object.keys(SHAPES);

    function refillQueue(){ if(queue.length<7){ const bag=Phaser.Utils.Array.Shuffle(TYPES.slice()); queue.push(...bag); } }
    function spawn(){ refillQueue(); const type=queue.shift(); const shape=SHAPES[type].map(r=>r.slice()); const tet={ type, shape, x:Math.floor((COLS-shape[0].length)/2), y:-2 };
      if(collide(tet,0,0)) { endGame(); return null; } return tet; }

    function collide(tet,dx,dy){ const {shape,x,y}=tet; for(let r=0;r<shape.length;r++) for(let c=0;c<shape[0].length;c++) if(shape[r][c]){ const nx=x+c+dx, ny=y+r+dy; if(nx<0||nx>=COLS||ny>=ROWS) return true; if(ny>=0 && grid[ny][nx]) return true; } return false; }
    function merge(tet){ const {shape,x,y,type}=tet; for(let r=0;r<shape.length;r++) for(let c=0;c<shape[0].length;c++) if(shape[r][c]){ const nx=x+c, ny=y+r; if(ny>=0) grid[ny][nx]=type; } }
    function rotate(mat){ const h=mat.length,w=mat[0].length,res=Array.from({length:w},()=>Array(h).fill(0)); for(let y=0;y<h;y++) for(let x=0;x<w;x++) res[x][h-1-y]=mat[y][x]; return res; }

    function computeGhost(){ ghost = JSON.parse(JSON.stringify(active)); while(!collide(ghost,0,1)) ghost.y++; }

    function clearLines(){ let cleared=0; for(let r=ROWS-1;r>=0;r--){ if(grid[r].every(v=>v)){ grid.splice(r,1); grid.unshift(Array(COLS).fill(0)); cleared++; r++; } }
      if(cleared){ const table=[0,100,300,500,800]; score += table[cleared]*level; lines += cleared; const newLevel = 1 + Math.floor(lines/10); if(newLevel>level){ level=newLevel; dropInterval=Math.max(80, 500 - (level-1)*40); }
        scoreText.textContent=score; linesText.textContent=lines; levelText.textContent=level; }
    }

    function hold(){ if(holdLocked) return; if(!holdType){ holdType=active.type; active=spawn(); } else { const tmp=active.type; active={ type:holdType, shape:SHAPES[holdType].map(r=>r.slice()), x:Math.floor((COLS-SHAPES[holdType][0].length)/2), y:-2 }; holdType=tmp; }
      holdLocked=true; if(!active) return; draw(); }

    function drawMini(type, ox, oy){ if(!type) return; const shape=SHAPES[type]; const s=CELL*0.6; // mini cell
      for(let r=0;r<shape.length;r++) for(let c=0;c<shape[0].length;c++) if(shape[r][c]){ g.fillStyle(COLORS[type],1); g.fillRect(ox+c*s, oy+r*s, s-2, s-2); } }

    function create(){ grid=Array.from({length:ROWS},()=>Array(COLS).fill(0)); refillQueue(); active=spawn(); if(!active) return; holdLocked=false; g=this.add.graphics();
      this.input.keyboard.on('keydown', e=>{
        if(e.key==='ArrowLeft' && !collide(active,-1,0)) active.x--;
        else if(e.key==='ArrowRight' && !collide(active,1,0)) active.x++;
        else if(e.key==='ArrowDown'){ if(!collide(active,0,1)){ active.y++; score+=1; scoreText.textContent=score; } }
        else if(e.key==='ArrowUp' || e.key==='x' || e.key==='X'){ const r=rotate(active.shape); const tmp={...active, shape:r}; if(!collide(tmp,0,0)) active.shape=r; }
        else if(e.key==='z' || e.key==='Z'){ const r=rotate(rotate(rotate(active.shape))); const tmp={...active, shape:r}; if(!collide(tmp,0,0)) active.shape=r; }
        else if(e.code==='Space'){ // hard drop
          let dist=0; while(!collide(active,0,1)){ active.y++; dist++; } score += dist*2; scoreText.textContent=score; step(true);
        } else if(e.key==='c' || e.key==='C' || e.key==='Shift'){ hold(); }
        else if(e.key==='p' || e.key==='P'){ this.scene.isPaused()? this.scene.resume(): this.scene.pause(); }
        draw();
      });
      draw();
    }

    function step(fromHard=false){ if(!collide(active,0,1)) { active.y++; } else { merge(active); clearLines(); active=spawn(); holdLocked=false; if(!active) return; }
    }

    function draw(){ g.clear();
      // board bg
      g.fillStyle(0x0b7a3b,1); g.fillRect(0,0,CELL*COLS,H);
      // side panel
      const panelX=COLS*CELL; g.fillStyle(0x064e3b,1); g.fillRect(panelX,0,PANEL,H);
      // placed blocks
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(grid[r][c]) drawCell(c,r,COLORS[grid[r][c]]);
      // ghost & active
      computeGhost(); for(let r=0;r<ghost.shape.length;r++) for(let c=0;c<ghost.shape[0].length;c++) if(ghost.shape[r][c]){ const gx=ghost.x+c, gy=ghost.y+r; if(gy>=0) drawCell(gx,gy,COLORS.ghost,0.18,true); }
      for(let r=0;r<active.shape.length;r++) for(let c=0;c<active.shape[0].length;c++) if(active.shape[r][c]){ const ax=active.x+c, ay=active.y+r; if(ay>=0) drawCell(ax,ay,COLORS[active.type]); }
      // grid lines
      g.lineStyle(1,0x0a6d35,0.6); for(let x=0;x<=COLS;x++){ g.beginPath(); g.moveTo(x*CELL,0); g.lineTo(x*CELL,H); g.strokePath(); } for(let y=0;y<=ROWS;y++){ g.beginPath(); g.moveTo(0,y*CELL); g.lineTo(CELL*COLS,y*CELL); g.strokePath(); }
      // panel labels
      g.fillStyle(0xffffff,1); g.fillRect(panelX+10,10,PANEL-20,24); g.fillRect(panelX+10,180,PANEL-20,24);
      const label = (txt,x,y)=>{ const t=document.createElement('canvas'); const ctx=t.getContext('2d'); t.width=1; t.height=1; }; // placeholder to avoid font usage inside Phaser text (keep code lightweight)
      // HOLD box
      g.lineStyle(2,0xffffff,1); g.strokeRect(panelX+10,40,PANEL-20,90);
      drawMini(holdType, panelX+24, 54);
      // NEXT box
      g.lineStyle(2,0xffffff,1); g.strokeRect(panelX+10,210,PANEL-20, H-220);
      // draw next 3
      for(let i=0;i<3;i++){ const t=queue[i]; if(!t) break; drawMini(t, panelX+24, 230 + i*80); }
    }

    function drawCell(c,r,color,alpha=1,ghostCell=false){ const x=c*CELL, y=r*CELL; g.fillStyle(color,alpha); g.fillRect(x+1,y+1,CELL-2,CELL-2); if(!ghostCell){ g.fillStyle(0xffffff,0.10); g.fillRect(x+2,y+2,CELL-4,Math.max(2,CELL*0.18)); g.fillStyle(0x000000,0.10); g.fillRect(x+2,y+CELL-4,CELL-4,2); } }

    function update(_,dt){ dropTimer += dt; if(dropTimer>dropInterval){ dropTimer=0; if(active) step(); draw(); } }

    function endGame(){ finalScore.textContent=score; finalLines.textContent=lines; finalLevel.textContent=level; overlay.style.display='flex'; game.scene.pause(); }

    // Restart flow
    restartBtn.addEventListener('click', ()=>{ overlay.style.display='none'; game.destroy(true); document.getElementById('phaser-parent').innerHTML=''; score=0; lines=0; level=1; scoreText.textContent=0; linesText.textContent=0; levelText.textContent=1; bootPhaser(); });

    // --- Lightweight runtime tests (console) ---
    console.groupCollapsed('Tetris runtime checks');
    console.assert(TYPES.length===7,'TYPES should be 7');
    console.assert(Object.values(SHAPES).every(s=>s.length>0),'All shapes exist');
    console.groupEnd();
  }
})();
</script>
</body>
</html>
